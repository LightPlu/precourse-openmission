# DDD 패턴을 적용하여 Refactoring 해보기

---

## Entity vs VO
- Entity : 가장 큰 특징은 식별자를 가진다는 것
  - 식별자 : Entity 객체마다 고유한 구분할 수 있는 기준
- VO : 개념적으로 완전한 하나를 표현할 수 있는 것
---
## 로또 프로젝트에서 어떻게 Entity와 VO를 구분해야 할까?

- 우선 Entity와 VO를 구분하기 전에 어떻게 프로젝트 구조를 가져갈지에 대해 말해보아야 한다.


- 현재 3주차 과제를 진행함에 있어 식별자를 가지는 Entity가 필요한가?
  - 3주차 과제에선 과거 로또 기록을 필요로 하지도 않고, 누가 샀는지에 대한 기록도 필요하지 않다
  - 단순히 금액을 입력하고, 해당 금액에 맞게 로또를 발행하고, 발행된 로또를 비교해서 당첨금을 계산하는 로직만 필요하다
  

- 그렇다면 식별자를 가지는 Entity와 VO를 구분하기 위해선 어떠한 전제조건이 필요한가?
  - 우선 식별자를 활용할 수 있도록 문제를 정의하는 것부터 시작해야 된다
  
---

## 로또에서는 어떤것이 식별자를 가지고, 어떠한 문제점이 존재할까?

- 식별자를 활용할 수 있도록 로또를 관련지어야 한다면 어떤 것이 존재할까?
  - 로또를 사봤거나 검색해보았다면 알 수 있겠지만 한 게임당 총 5번의 로또 번호를 추첨할 수 있다 (ex: [1,2,3,4,5,6], [7,8,9,10,11,12], ...)
  - 로또 한 게임은 영수증과 같이 종이로 보관되기 때문에 해당 게임의 식별자를 두어 각 게임별로 구분지을 수 있다
  - 현재 로또 게임에 대하여 검색해본다면 각 회차별 당첨금액이 4,5등을 제외하고 다 다르다. 이는 각 회차별 로또 구매 금액이 매번 다르기 때문이다. 왜 다른지는 검색을 해본다면 보다 자세히 알 수 있다
    - 이를 통해 각 회차별로도 식별자를 가져 회차별로 구분할 수 있게 해야함을 의미한다

  
- 그렇다면 어떠한 것들이 식별자를 가지는 것인지 정리해보자
  - 로또의 각 게임 식별자 (로또 5번당 영수증 1개, 이때 영수증이 게임을 의미)
  - 로또의 각 회차 (로또에는 각 회차마다 등수별 몇명 당첨되었는지, 당첨금은 얼마인지에 대해 설명한다)

    
- 왜 로또는 개인정보를 활용해서 로또 구매에 대하여 저장해두지 않아서 실물 로또 분실시 당첨금을 수령할 수 없는 문제점을 아직도 해결하지 못하였는가?
  - 개인적인 생각으로 개인정보를 활용하여 구매한 로또에 대하여 구매 정보를 저장해두면 좋지 않을까 생각을 하고 인터넷 검색을 해보았더니 이미 2023년에 동행복권 웹사이트 해킹사건이 존재했다. 
  - 이는 이미 보안적으로 철저하게 관리한다고 해도 해킹은 발생할 수 있고, 언제든 개인정보 유출에 의한 위험 가능성이 존재한다는 것을 의미한다.
  - 만약 실물 로또에 개인정보를 추가하여 저장해둔다 하더라도 개인정보를 저장하고 있는 서비스가 해킹을 통하여 공격당한다면 여전히 피해를 입을 가능성이 존재한다.
  - 이처럼 인터넷 복권의 필요성을 느껴 인터넷 서비스는 개발하되, 기존 실물 복권은 사람들의 수요가 존재하고 접근성이 편한 장점때문에 아직까지 로또 분실의 책임을 사람들에게 남겨두고 실물 복권을 유지하고 있다고 생각한다.

---

## 그렇다면 식별자를 가지는 Entity와 하나를 표현하는 VO를 가지는 로또 프로젝트를 구현한다면 어떠한 것들로 나눌 수 있을까?
### 현재 3주차 과제에서는 각 회차별로 저장할 필요가 없어 사실 모든 것을 VO로 둬도 상관 없다고 생각한다. 한번 정해지면 바뀌는 것이 없기 때문이다. 하지만 이번 오픈미션에선 DDD 패턴에 대해 학습한 것을 적용하기 위한 리팩토링을 진행하기 때문에 상황을 가정하는 것부터 시작해야한다.

---

##  Entity를 두기 위하여 문제 정의를 가정해보겠다
  - 각 로또를 실물 로또를 통하여 구분해야 한다.
  - 각 회차별로 당첨 내역 및 당첨번호를 제공해야 한다

---

## Entity 및 VO

- 식별자로 인해 구분해야 하는 것(Entity)
  - Round(로또게임의 각 회차)[Aggregate Root]
    - 로또의 각 회차를 관리한다.
  - LottoTicket(로또의 각 게임)
    - 각 게임에는 최소 1개, 최대 5개의 로또 추첨이 들어갈 수 있다
    - 각 티켓별로 최종 당첨금을 계산하는 로직이 구현되어야 한다.
  - LottoResult(로또의 각 회차)
    - 각 회차별 등수마다 몇개의 당첨이 존재하고, 당첨금액은 얼마인지에 대해 표현한다.
  - WinningLottoNumbers(로또의 각 당첨번호)
    - 각 회차별 당첨번호는 어떻게 되는지에 대해 저장해둔다.
    - 각 회차별로 당첨금액처럼 저장만 해두면 되지 굳이 Entity로 정해야하나?
      - 확률적으로 가능할 진 모르겠지만 당첨번호를 보고 수동으로 로또 번호를 추첨하는 사람이 있을 수 있다. 그런 사람들을 위해 당첨번호만 조회할 수 있도록 따로 저장해두면 좋다고 생각된다.
      


- VO로 구분할 수 있는 것
  - Cash(로또 금액)
  - LottoNumber(로또 번호)
  - Lotto(각 로또 1번 구매[1000원])
  - Rank(등수)
  - CountResult(각 로또별 번호가 몇개 맞았는지에 대한 VO)
  - PrizeDetail(각 게임마다(로또 1~5개) 등수 카운팅 및 상금)


---

## Use case
### Use case : 사용자가 애플리케이션을 통해 하고자 하는 "행동(목적)"을 표현한 것

- Round 관련 Use case
  - 최신 회차 조회
  - 새로운 회차 시작
  - 특정 회차 상세 조회
  - 특정 회차 LottoTicket들과 당첨 번호를 비교


- Ticket 관련 Use case
  - Lotto Ticket 발행
  - 특정 회차 티켓 목록 조회(필요할까?)


- WinningLottoNumber 관련 Use case
  - 당첨 번호 등록
  - 특정 회차 당첨 번호 조회


- Round Result 관련 Use case
  - Round Result 저장
  - 특정 회차 결과 조회


- Round 종료 및 그 다음 회차 시작 Use case[제일 중요한 Use case]
  - 1. roundNumber로 한 회차의 모든 Ticket 조회
  - 2. roundNumber로 해당 회차의 당첨 번호 조회
  - 3. 로또 티켓 비교 로직을 통해 모든 Ticket 비교
  - 4. 회차 결과를 다루는 RoundResult 저장
  - 5. 다음 회차 자동 시작


## 프로젝트를 리팩토링 하며 생긴 의문점

- Cash VO 내에 금액을 통하여 로또를 발행할 횟수를 저장하는 멤버변수 fullGameCount, remainingGameCount 멤버 변수를 따로 GameCount VO로 나누는 것이 맞을까?
  - 만약 GameCount를 통해서 다른 도메인 규칙이 생긴다면나누는게 맞다고 생각하지만, 현재 로또 규칙상 최대 금액 제한만 있으므로 굳이 나누지 않는다
  - Cash VO에서 최대 금액을 설정해두고 만약 최대 금액을 넘어선다면 에러를 발생하면 되기 때문이다


- 현재 PrizeDetail 클래스와 Rank 클래스는 같은 역할을 하는 것 아닌가?
  - 똑같이 Rank와 상금 및 갯수에 대해 다루고 있어서 혼동할 수 있다.
  - PrizeDetail VO같은 경우 한 Ticket당 등수별 몇개의 당첨이 됐는지, Ticket에서의 총 상금은 어떻게 되는지에 대한 VO이다.


- 현재 LottoResult Entity를 통해서 회차당 당첨된 내역들을 저장하려 했는데 현재 구현하는 도중 티켓별로 당첨 내역을 저장하기 위해 LottoResult를 사용했다. 어떻게 추후 구현을할까?
  - 우선 생각을 해보면 티켓별 내역을 굳이 저장해야하나? 필요없다. Entity -> VO로 이동시키자. 그러면 어떻게 회차별로 저장을 하지? 저장할 때 그저 회차내 모든 LottoResult들을 다 조회해서 더해야하나? 그렇다기엔 LottoResult를 DB에 저장해두기엔 너무 많은 공간 낭비가 들어간다.
  - LottoResult를 VO로 이동시키고, RoundResult를 Entity에 추가하여 당첨과 관련된 Aggregate Root로 만들자.
  - Round를 관리하는 Entity가 없으므로 Round Entity를 추가하고 해당 Entity를 Aggregate Root로 만듦. RoundResult Aggregate Root 아님.


- RoundResult를 구현하는 과정에서 평탄화라는 개념이 등장하는데 평탄화란것은 무엇일까?
  - 평탄화란 중첩된 자료구조(리스트 안의 리스트)를 한 단계로 펼치는 것을 말한다.
  - List<List<PrizeDetail>> -> List<PrizeDetail>.
  - 근데 과연 한 시점에서의 RoundResult를 구현하기 위해 평탄화를 적용시켜서 모든것들에 대한 계산을 하는게 성능적으로 좋을까?


- 로또의 당첨 내역은 일반적으로 생각해본다면 보너스번호를 입력한 시점 기준으로 발행된 모든 로또들의 당첨이 계산된다. 과연 한번에 모든것을 불러와서 비교하는것이 성능적으로 우세한가 아니면 티켓 하나하나 비교하면서 추가하는 것이 우세한가?
  - 우선 실물 로또는 사실 비교는 본인들이 하기때문에 이러한 과정을 고민할 필요가 없다. 하지만 인터넷으로 구매한 로또라면 분명 해당 로직에 대해서도 동행복권 내에서 고민했을 것이기 때문에 한번 찾아보려한다.
  - ![img_1.png](img_1.png)
  - LLM을 통해서 공부를 하던 도중 benchmark테스트를 해볼 수 있다고 해서 한번 새로운 프로젝트를 만들어 flatMap을 통한 평탄화를 적용시킨 과정과, for루프를 통해서 집계를 하는 것의 차이점에 대해 benchmark를 돌려보았다.
  - 해당 과정을 통해 적은 데이터를 가지고 구현한다면 flatMap과 for루프의 차이점은 없었지만, 10만건 아래로 데이터수가 증가한다면 for루프가 훨씬 빠르다는 것을 확인하였다.
  - 하지만 로또는 검색해본다면 평균 회차당 5700만장이 팔린다는 것을 알 수 있다. 과연 내가 로직상으로 모든 것들을 불러와서 조희해서 계산하는 것이 짧은 시간내로 가능할까? 절대 안된다고 본다. DB에서 가능한지 추후에 DB를 연결하는 과정에서 알아보자.


- 과연 Lotto는 Entity로 보는것이 맞을까 VO로 보는것이 맞을까?
  - Lotto를 Entity로 본다면 DB 테이블을 생성하고, LottoTicket과 Lotto를 1:N관계로 봐야한다.
  - Lotto를 VO로 본다면 DB 테이블을 생성하지 않고, LottoTicket DB 테이블에 해당 Lotto들을 전부 저장한다.
  - 그렇다면 Lotto를 Entity로 보아야하는가? 아니면 VO로 보아야하는가?
    - 우선 로또 한개의 정보를 바탕으로 활용하는 것이 존재하는가?
      - 만약 로또를 1개만 구매한다면 티켓1장에 로또 1개가 들어있다. 그렇게 된다면 과연 의미가 있을까?
      - 어차피 티켓단위로 당첨번호와 비교할 것이기 때문에 필요 없다고 생각이 든다.
      - 따로 로또를 활용해서 번호 추첨 확률을 계산하고 특별한 로직이 존재하지 않기 때문에 따로 DB 테이블을 만들지 않아도 된다고 판단.
    - 만약 LottoTicket에 Lotto 리스트들을 모두 집어넣는다면 DB 정규화가 지켜지지 않는다. 이에 대한 판단은?
      - 현재 프로젝트는 DDD에 대한 학습과 적용을 우선시하고 있음 따라서 Lotto를 LottoTicket 테이블에 뭉탱이로 집어넣을 것. 만약 DB 정규화를 지켜야하는 프로젝트라면 Entity로 구분하는 것이 맞다고 판단.


- 티켓들을 한번에 DB에 저장하는 방법이 없을까? 만약 여러장 산다면 INSERT 쿼리가 여러번? 그러면 성능상 안좋아지지 않나?
  - Batch를 통해 INSERT 쿼리문을 한번만 쓰는것처럼 구현 가능. Batch에 대해선 추후 자세히 공부해볼 예정.


- 갑자기 발생한 git push 500 ERROR!!!!! 도대체 왜 갑자기? 살면서 한번도 이래본적이 없는데?
  - ?? 기존 커밋들 다 리셋하고 하나하나 커밋마다 push하니까 된다. 도대체 뭐지 진짜?
  - 디스코드에도 물어보고, 웹서핑도 해봤는데 파일 크기 문제라고는 하는데 내 프로젝트 파일들은 전부 합쳐서 지금 1.6MB 밖에 안되는데 파일 크기 문제는 아닌거같다. 정말 이상하네


- 현재 도메인 서비스에서 LottoTicket List를 반환하도록 메서드를 만들어놨는데 그럼 몇회차인지에 대해 어떻게 알고 Ticket을 만들지?
  - 도메인 서비스에서는 List<List<Lotto>>로 로또들을 5개이내로 묶은 리스트만을 반환하고 Application Service에서 회차에 대한 정보를 주입하여 LottoTicket을 만들자


- DIP를 유지하기 위해선 생성자로부터 의존성 주입을 받아야 하는데 그렇다면 최중 Root는 new를 사용해 객체를 생성해야하는 것 아닌가? 그럴려면 모든 계층에 의존해야 하는데 그래도 괜찮은 것인가?
  - 애플리케이션의 가장 바깥쪽에 config를 만들어 Composition Root 에서만 new를 통해 객체를 생성하고 해당 객체들을 주입한다.
  - Composition Root : 애플리케이션 전체에서 객체를 생성하고 의존성을 조립하는 유일한 위치(Spring 없이 Spring Container를 대신하는 곳)
  - 자동 DI(Dependency Injection), 수동 DI가 존재
  - 자동 DI는 Spring, NestJS 등이 자동으로 주입해주는 것을 의미하고, 수동 DI는 개발자가 직접 new 객체를 통해 주입하는 것을 의미
  - 현재 나의 프로젝트에서는 수동 DI 방식을 사용하여 개발자가 직접 주입해줘야 하는데 DIP 원칙을 적용하기 위해 각 계층에선 new 객체를 통하지 않고 Application의 최상위인 config 에서 필요한 모든 것을 new 객체로 생성하고 주입
  - Composition Root 를 도입하여 의존성 주입에 대한 주체를 ApplicationConfig에 둔다면 Clean Architecture를 지킬 수 있다고 한다. 해당 관련된 책도 책 묶음에 있었던거 같은데 한번 오픈미션 끝나고 읽어봐야겠다.


- 현재 로또를 4000원을 입력해서 티켓이 1장만 발행되어야 하는데 티켓들이 5번의 로또 꽉꽉으로 800장이 발행됐다 하.. 테스트코드의 중요성.....
  - 로또 티켓을 구매하는 카운트 로직을 잘못 구현했다.. 왜 그랬지.. 다행히도 금방 찾음(Cash VO내의 Count값을 구하는 로직 문제)
  - 옛날이였으면 도대체 어디가 문제인지 빠르게 못찾고 모든 로직들 하나하나 뜯어가면서 찾았으면 시간 엄청 걸렸을텐데 테스트코드 작성하는 방법을 배운 뒤 활용하니 정말 금방 찾았다.
  - 확실히 테스트코드는 무조건 작성하는게 맞다.


- 왜 LottoNumber에 Comparable을 상속받아야 되는지 모르겠음


- 현재 DB에 쿼리를 날리는 도중 에러가 발생. 
  - 테이블 몇, 컬럼 명 다 잘 확인하기. 비슷해보인다고 그냥 넘어가면 안된다. 하나하나 맞는지 다 확인해봐야한다.

  
- 현재 Controller에 RoundResult가 노출되어있다. 어떻게 해당 도메인을 숨길 수 있을까?
  - 다른 도메인 같은 경우에는 List로 숨길 수 있다. 단순한 숫자들의 집합이기 때문이다.
  - RoundResult 같은 경우는 Rank와 Integer 타입의 Map 이다. 어떻게 숨기지?
    - DTO를 만들어 Application Service에서 domain을 DTO로 변환하여 반환한다면 domain을 숨길 수 있다.
    - 해당 내용은 Clean Architecture 에서 다룬다고 한다. 일지에도 써놨지만 오픈미션 끝나면 한번 읽어봐야겠다. DDD 주도 개발 시작하기 책과 같이 내 궁금증을 잘 긁어줄 책일 것 같다.
    - 근데 다시 생각해보니 굳이 RoundResult 하나때문에 DTO를 따로 만들어야 할까?
      - Map<String, Integer>로 넘기자. 이 생각을 못했다.